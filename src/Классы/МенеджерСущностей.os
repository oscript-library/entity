#Использовать asserts
#Использовать logos
#Использовать reflector

// Хранит данные о типах полей, колонках, настроек таблиц для типов сущностей
Перем МодельДанных;

// Хранит коннектор к БД, транслирующий команды менеджера сущностей в запросы к БД
Перем Коннектор;
Перем СтрокаСоединенияКоннектора;
Перем ПараметрыКоннектора;

Перем Лог;

// Конструктор объекта МенеджерСущностей.
//
// Параметры:
//   ТипКоннектора - Тип - Тип класса, реализующего интерфейс Коннектор.
//   СтрокаСоединения - Строка - Строка соединения к БД, к которой подключается коннектор.
//   ППараметрыКоннектора - Соответствие - Дополнительные параметры коннектора. Содержимое произвольное.
//
Процедура ПриСозданииОбъекта(Знач ТипКоннектора, Знач СтрокаСоединения = "", Знач ППараметрыКоннектора = Неопределено)
	Лог = Логирование.ПолучитьЛог("oscript.lib.entity.manager");
	Лог.Отладка("Инициализация менеджера сущностей с коннектором %1", ТипКоннектора);
	ПроверитьПоддержкуИнтерфейсаКоннектора(ТипКоннектора);
	
	Ожидаем.Что(ТипКоннектора, "Неверный тип параметра ТипКоннектора").ИмеетТип(Тип("Тип"));
	Если СтрокаСоединения <> Неопределено Тогда
		Ожидаем.Что(СтрокаСоединения, "Неверный тип параметра СтрокаСоединения").ИмеетТип(Тип("Строка"));
	КонецЕсли;
	Если ППараметрыКоннектора <> Неопределено Тогда
		Ожидаем.Что(ТипКоннектора, "Неверный тип параметра ТипКоннектора").ИмеетТип(Тип("Соответствие"));
	КонецЕсли;

	МодельДанных = Новый МодельДанных;
	
	Коннектор = Новый(ТипКоннектора);
	
	СтрокаСоединенияКоннектора = СтрокаСоединения;
	Если ППараметрыКоннектора = Неопределено Тогда
		ПараметрыКоннектора = Новый Соответствие;
	Иначе
		ПараметрыКоннектора = ППараметрыКоннектора;	
	КонецЕсли;
КонецПроцедуры

// Регистрирует переданный тип класса-сценария в модели данных.
//
// Параметры:
//   ТипСущности - Тип - Тип для добавления в модель
//
Процедура ДобавитьКлассВМодель(ТипСущности) Экспорт
	ПроверитьЧтоКлассЯвляетсяСущностью(ТипСущности);
	
	МодельДанных.СоздатьОбъектМодели(ТипСущности);
КонецПроцедуры

// Запускает процессы инициализации коннектора и таблиц БД.
//
Процедура Инициализировать() Экспорт
	Коннектор.Открыть(СтрокаСоединенияКоннектора, ПараметрыКоннектора);
	ОбъектыМодели = МодельДанных.ПолучитьОбъектыМодели();
	Для Каждого ОбъектМодели Из ОбъектыМодели Цикл
		Коннектор.ИнициализироватьТаблицу(ОбъектМодели);
	КонецЦикла;
КонецПроцедуры

// Сохраняет сущность в БД.
//
// Параметры:
//   Сущность - Произвольный - Объект (экземпляр класса, зарегистрированного в модели) для сохранения в БД.
//
Процедура Сохранить(Сущность) Экспорт
	ТипСущности = ТипЗнч(Сущность);

	ПроверитьЧтоКлассЯвляетсяСущностью(ТипСущности);
	ПроверитьЧтоТипСущностиЗарегистрированВМодели(ТипСущности);
	ПроверитьНеобходимостьЗаполненияИдентификатора(Сущность);

	ОбъектМодели = МодельДанных.Получить(ТипСущности);
	
	Коннектор.Сохранить(ОбъектМодели, Сущность);
КонецПроцедуры

// Осуществляет поиск сущностей переданного типа по идентификатору.
//
// Параметры:
//   ТипСущности - Тип - Тип искомой сущности.
//   Отбор - Произвольный - Отбор для поиска. 
//     Если параметр не задан или равен "Неопределено", то возвращаются все найденные сущности указанного типа.
//     Если параметр имеет тип "Соответствие", то каждое значение соответствия преобразуется к условию поиска
//      ИмяПоля = ЗначениеПоля, где ИмяПоля - ключ элемента соответствия, ЗначениеПоля - значение элемента соответствия.
//     Если параметр имеет тип "Массив", то каждое элемент массива должен иметь тип "ЭлементОтбора".
//       Каждый элемент отбора преобразуется к условию поиска. В качестве "ПутьКДанным" указываются имена полей.
//     Если параметр имеет тип "ЭлементОтбора", то элемент отбора преобразуется к условию поиска. 
//       В качестве "ПутьКДанным" указываются имена полей.
//
//  Возвращаемое значение:
//   Массив - Массив найденных сущностей. В качестве элементов массива выступают
//     экземпляры класса с типом, равным переданному "ТипуСущности", с заполненными значениями полей.
//
Функция Получить(ТипСущности, Отбор = Неопределено) Экспорт
	
	ОбъектМодели = МодельДанных.Получить(ТипСущности);
	Колонки = ОбъектМодели.Колонки();
	
	ПередаваемыйОтбор = Новый Массив;
	
	Если ТипЗнч(Отбор) = Тип("Соответствие") Тогда
		// Переформируем ключи отбора из имен полей в имена колонок
		Для Каждого КлючИЗначение Из Отбор Цикл
			Колонка = Колонки.Найти(КлючИЗначение.Ключ, "ИмяПоля");
			Ожидаем.Что(
				Колонка, 
				СтрШаблон("Не удалось найти данные о колонке по имени поля %1", КлючИЗначение.Ключ)
			).Не_().Равно(Неопределено);

			ПередаваемыйОтбор.Добавить(Новый ЭлементОтбора(Колонка.ИмяКолонки, ВидСравнения.Равно, КлючИЗначение.Значение));
		КонецЦикла;
	ИначеЕсли ТипЗнч(Отбор) = Тип("Массив") Тогда
		Для Каждого ЭлементОтбора Из Отбор Цикл
			Колонка = Колонки.Найти(ЭлементОтбора.ПутьКДанным, "ИмяПоля");
			Ожидаем.Что(
				Колонка, 
				СтрШаблон("Не удалось найти данные о колонке по имени поля %1", ЭлементОтбора.ПутьКДанным)
			).Не_().Равно(Неопределено);

			ПередаваемыйОтбор.Добавить(Новый ЭлементОтбора(Колонка.ИмяКолонки, ЭлементОтбора.ВидСравнения, ЭлементОтбора.Значение));
		КонецЦикла;
	ИначеЕсли ТипЗнч(Отбор) = Тип("ЭлементОтбора") Тогда
		ЭлементОтбора = Отбор;
		Колонка = Колонки.Найти(ЭлементОтбора.ПутьКДанным, "ИмяПоля");
			Ожидаем.Что(
			Колонка, 
			СтрШаблон("Не удалось найти данные о колонке по имени поля %1", ЭлементОтбора.ПутьКДанным)
		).Не_().Равно(Неопределено);
		
		ПередаваемыйОтбор.Добавить(Новый ЭлементОтбора(Колонка.ИмяКолонки, ЭлементОтбора.ВидСравнения, ЭлементОтбора.Значение));
	ИначеЕсли Отбор = Неопределено Тогда
		// no-op
	Иначе
		ВызватьИсключение "В метод получения данных передан неожиданный тип отбора: " + ТипЗнч(Отбор);
	КонецЕсли;

	НайденныеСущности = Новый Массив;
	
	НайденныеСтроки = Коннектор.НайтиСтрокиВТаблице(ОбъектМодели, ПередаваемыйОтбор);
	Если НайденныеСтроки.Количество() = 0 Тогда
		Возврат НайденныеСущности;
	КонецЕсли;
	
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		Сущность = Новый(ТипСущности);

		Для Каждого Колонка Из Колонки Цикл
			ЗначениеКолонки = НайденнаяСтрока.Получить(Колонка.ИмяКолонки);
			Если Колонка.ТипКолонки = ТипыКолонок.Ссылка И ЗначениеЗаполнено(ЗначениеКолонки) Тогда
				ЗначениеКолонки = ПолучитьОдно(Колонка.ТипСсылки, ЗначениеКолонки);
			КонецЕсли;
			ОбъектМодели.УстановитьЗначениеКолонкиВПоле(Сущность, Колонка.ИмяКолонки, ЗначениеКолонки);
		КонецЦикла;

		НайденныеСущности.Добавить(Сущность);
	КонецЦикла;
	
	Возврат НайденныеСущности;
	
КонецФункции

// Осуществляет поиск сущности переданного типа по идентификатору.
//
// Параметры:
//   ТипСущности - Тип - Тип искомой сущности.
//   Отбор - Произвольный - Отбор для поиска. 
//     Если параметр не задан или равен "Неопределено", то возвращаются все найденные сущности указанного типа.
//     Если параметр имеет тип "Соответствие", то каждое значение соответствия преобразуется к условию поиска.
//      ИмяПоля = ЗначениеПоля, где ИмяПоля - ключ элемента соответствия, ЗначениеПоля - значение элемента соответствия.
//     Если параметр имеет тип "Массив", то каждое элемент массива должен иметь тип "ЭлементОтбора".
//       Каждый элемент отбора преобразуется к условию поиска. В качестве "ПутьКДанным" указываются имена полей.
//     Если параметр имеет тип "ЭлементОтбора", то элемент отбора преобразуется к условию поиска. 
//       В качестве "ПутьКДанным" указываются имена полей.
//     Любой другой тип интерпретируется как поиск по &Идентификатору.
//
//  Возвращаемое значение:
//   Произвольный - Если сущность была найдена, то возвращается экземпляр класса с типом, равным переданному 
//     "ТипуСущности", с заполненными значениями полей. Иначе возвращается "Неопределено".
//
Функция ПолучитьОдно(ТипСущности, Знач Отбор = Неопределено) Экспорт
	ОбъектМодели = МодельДанных.Получить(ТипСущности);
	
	Если Отбор = Неопределено Тогда
		ПередаваемыйОтбор = Отбор;
	ИначеЕсли ТипЗнч(Отбор) = Тип("Соответствие") Тогда
		ПередаваемыйОтбор = Отбор;
	ИначеЕсли ТипЗнч(Отбор) = Тип("Массив") Тогда
		ПередаваемыйОтбор = Отбор;
	ИначеЕсли ТипЗнч(Отбор) = Тип("ЭлементОтбора") Тогда
		ПередаваемыйОтбор = Отбор;
	Иначе
		ПередаваемыйОтбор = Новый Соответствие();
		ПередаваемыйОтбор.Вставить(ОбъектМодели.Идентификатор().ИмяПоля, Отбор);
	КонецЕсли;
	
	НайденныеСущности = Получить(ТипСущности, ПередаваемыйОтбор);
	
	Если НайденныеСущности.Количество() = 0 Тогда
		Возврат Неопределено;
	Иначе
		Возврат НайденныеСущности[0];
	КонецЕсли;
КонецФункции

// Удаляет удаление сущности из базы данных.
// Сущность должна иметь заполненный идентификатор.
//
// Параметры:
//   Сущность - Произвольный - Удаляемая сущность
//
Функция Удалить(Сущность) Экспорт
	ОбъектМодели = МодельДанных.Получить(ТипЗнч(Сущность));
	Коннектор.Удалить(ОбъектМодели, Сущность);
КонецФункции

// Посылает коннектору запрос на закрытие соединения.
//
Процедура Закрыть() Экспорт
	Если Коннектор.Открыт() Тогда
		Коннектор.Закрыть();
	КонецЕсли;
	МодельДанных.Очистить();
КонецПроцедуры

// Посылает коннектору запрос на начало транзакции.
//
Процедура НачатьТранзакцию() Экспорт
	Коннектор.НачатьТранзакцию();
КонецПроцедуры

// Посылает коннектору запрос на фиксацию транзакции.
//
Процедура ЗафиксироватьТранзакцию() Экспорт
	Коннектор.ЗафиксироватьТранзакцию();
КонецПроцедуры

// Посылает коннектору запрос на отмену транзакции.
//
Процедура ОтменитьТранзакцию() Экспорт
	Коннектор.ОтменитьТранзакцию();
КонецПроцедуры

// Возвращает текущий активный коннектор.
//
//  Возвращаемое значение:
//   АбстрактныйКоннектор - Возвращает экземпляр коннектора. Конкретная реализация определяется параметром 
//      ТипКоннектора при вызове конструктора МенеджерСущностей. 
//
Функция ПолучитьКоннектор() Экспорт
	Возврат Коннектор;
КонецФункции

// <Описание процедуры>
//
// Параметры:
//   ТипКоннектора - Тип - Тип, проверяемый на реализацию интерфейса
//
Процедура ПроверитьПоддержкуИнтерфейсаКоннектора(ТипКоннектора)
	
	ИнтерфейсКоннектор = Новый ИнтерфейсОбъекта;
	ИнтерфейсКоннектор.ИзОбъекта(Тип("АбстрактныйКоннектор"));

	РефлекторОбъекта = Новый РефлекторОбъекта(ТипКоннектора);
	ПоддерживаетсяИнтерфейсКоннектора = РефлекторОбъекта.РеализуетИнтерфейс(ИнтерфейсКоннектор);
	
	Ожидаем.Что(
		ПоддерживаетсяИнтерфейсКоннектора, 
		СтрШаблон("Тип <%1> не реализует интерфейс коннектора", ТипКоннектора)
	).ЭтоИстина();

КонецПроцедуры

// <Описание процедуры>
//
// Параметры:
//   ТипКласса - Тип - Тип, в котором проверяется наличие необходимых аннотаций.
//
Процедура ПроверитьЧтоКлассЯвляетсяСущностью(ТипКласса)
	
	РефлекторОбъекта = Новый РефлекторОбъекта(ТипКласса);
	ТаблицаМетодов = РефлекторОбъекта.ПолучитьТаблицуМетодов("Сущность", Ложь);
	Ожидаем.Что(ТаблицаМетодов, СтрШаблон("Класс %1 не имеет аннотации &Сущность", ТипКласса)).ИмеетДлину(1);
	
	ТаблицаСвойств = РефлекторОбъекта.ПолучитьТаблицуСвойств("Идентификатор");
	Ожидаем.Что(ТаблицаСвойств, СтрШаблон("Класс %1 не имеет поля с аннотацией &Идентификатор", ТипКласса)).ИмеетДлину(1);

КонецПроцедуры

Процедура ПроверитьЧтоТипСущностиЗарегистрированВМодели(ТипСущности)
	ОбъектМодели = МодельДанных.Получить(ТипСущности);
	Ожидаем.Что(ОбъектМодели, "Тип сущности не зарегистрирован в модели данных").Не_().Равно(Неопределено);
КонецПроцедуры

Процедура ПроверитьНеобходимостьЗаполненияИдентификатора(Сущность)
	ОбъектМодели = МодельДанных.Получить(Тип(Сущность));
	Если ОбъектМодели.Идентификатор().ГенерируемоеЗначение Тогда
		Возврат;
	КонецЕсли;
	
	ЗначениеИдентификатора = ОбъектМодели.ПолучитьЗначениеИдентификатора(Сущность);
	Ожидаем.Что(
		ЗначениеИдентификатора, СтрШаблон("Сущность с типом %1 должна иметь заполненный идентификатор", Тип(Сущность))
	).Заполнено();

КонецПроцедуры
